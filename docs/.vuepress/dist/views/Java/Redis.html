<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis | Coloring</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="We beat on the boats against the current.">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.6dcf3714.css" as="style"><link rel="preload" href="/assets/js/app.12534202.js" as="script"><link rel="preload" href="/assets/js/3.3275429a.js" as="script"><link rel="preload" href="/assets/js/1.97ecb029.js" as="script"><link rel="preload" href="/assets/js/29.f9b50025.js" as="script"><link rel="prefetch" href="/assets/js/10.c978ae0a.js"><link rel="prefetch" href="/assets/js/11.036e9537.js"><link rel="prefetch" href="/assets/js/12.4b5f2216.js"><link rel="prefetch" href="/assets/js/13.1669d2ea.js"><link rel="prefetch" href="/assets/js/14.a6558952.js"><link rel="prefetch" href="/assets/js/15.0ec36145.js"><link rel="prefetch" href="/assets/js/16.555e041a.js"><link rel="prefetch" href="/assets/js/17.caa0e107.js"><link rel="prefetch" href="/assets/js/18.5a691b3e.js"><link rel="prefetch" href="/assets/js/19.06f2a46d.js"><link rel="prefetch" href="/assets/js/20.0a70569e.js"><link rel="prefetch" href="/assets/js/21.6a59b04c.js"><link rel="prefetch" href="/assets/js/22.25e82912.js"><link rel="prefetch" href="/assets/js/23.68f35fb7.js"><link rel="prefetch" href="/assets/js/24.e742cddd.js"><link rel="prefetch" href="/assets/js/25.97645b78.js"><link rel="prefetch" href="/assets/js/26.8b563143.js"><link rel="prefetch" href="/assets/js/27.c86a57bd.js"><link rel="prefetch" href="/assets/js/28.6b1e2e5c.js"><link rel="prefetch" href="/assets/js/30.b1103572.js"><link rel="prefetch" href="/assets/js/31.097c33e1.js"><link rel="prefetch" href="/assets/js/32.1011a38f.js"><link rel="prefetch" href="/assets/js/33.ad4cc8f5.js"><link rel="prefetch" href="/assets/js/34.85dd29a7.js"><link rel="prefetch" href="/assets/js/35.4425c421.js"><link rel="prefetch" href="/assets/js/36.70caa22c.js"><link rel="prefetch" href="/assets/js/37.073232a9.js"><link rel="prefetch" href="/assets/js/38.f0a51a63.js"><link rel="prefetch" href="/assets/js/39.3532b2bb.js"><link rel="prefetch" href="/assets/js/4.cb0d85f9.js"><link rel="prefetch" href="/assets/js/40.568c1d4c.js"><link rel="prefetch" href="/assets/js/41.a4b50133.js"><link rel="prefetch" href="/assets/js/42.21df5539.js"><link rel="prefetch" href="/assets/js/43.48ee0f43.js"><link rel="prefetch" href="/assets/js/5.a6872ff8.js"><link rel="prefetch" href="/assets/js/6.02f11781.js"><link rel="prefetch" href="/assets/js/7.ad07af39.js"><link rel="prefetch" href="/assets/js/8.2c68d8b8.js"><link rel="prefetch" href="/assets/js/9.553fb9b2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6dcf3714.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>Coloring</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>We beat on the boats against the current.</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><!---->
            
          <span data-v-4e82dffc>2019 - </span>
          2022
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/head.png" alt="Coloring" class="logo"> <span class="site-name">Coloring</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/categories/DeepLearning/" class="nav-link"><i class="undefined"></i>
  DeepLearning
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/otherNotes/" class="nav-link"><i class="undefined"></i>
  otherNotes
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="https://github.com/Colo-ring" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/head.png" alt="author-avatar" class="personal-img" data-v-828910c6> <!----> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>31</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>28</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/categories/DeepLearning/" class="nav-link"><i class="undefined"></i>
  DeepLearning
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/otherNotes/" class="nav-link"><i class="undefined"></i>
  otherNotes
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="https://github.com/Colo-ring" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>Redis</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><!---->
            
          <span data-v-4e82dffc>2019 - </span>
          2022
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">Redis</h1> <div class="page-info" data-v-067d6889><!----> <i class="iconfont reco-date" data-v-067d6889><span data-v-067d6889>11/16/2021</span></i> <!----> <i class="tags iconfont reco-tag" data-v-067d6889><span class="tag-item" data-v-067d6889>Java</span><span class="tag-item" data-v-067d6889>Redis</span></i></div></div> <div class="theme-reco-content content__default"><p>https://gitee.com/huyi612/hm-dianping</p> <h2 id="redis安装"><a href="#redis安装" class="header-anchor">#</a> Redis安装</h2> <p><strong>准备工作：下载安装最新版的gcc编译器</strong></p> <p>安装C 语言的编译环境</p> <ul><li><strong>yum</strong> <strong>install centos-release-scl scl-utils-build</strong></li> <li><strong>yum install -y devtoolset-8-toolchain</strong></li> <li><strong>scl enable devtoolset-8 bash</strong></li></ul> <p><strong>测试</strong> <strong>gcc版本</strong></p> <ul><li><strong>gcc --version</strong></li></ul> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201312617.png" alt="image-20211220131210046"></p> <p><strong>下载redis-6.2.1.tar.gz放/opt目录</strong></p> <p><strong>解压命令：tar -zxvf redis-6.2.1.tar.gz</strong></p> <p><strong>解压完成后进入目录：cd redis-6.2.1</strong></p> <p><strong>在redis-6.2.1目录下再次执行make命令（只是编译好）</strong></p> <p><strong>如果没有准备好C语言编译环境，make会报错—Jemalloc/jemalloc.h：没有那个文件</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201312491.png" alt=""></p> <p><strong>解决方案：运行make distclean</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201312640.png" alt="image-20211220131254622"></p> <p><strong>在redis-6.2.1目录下再次执行make命令（只是编译好）</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201313069.png" alt="image-20211220131303931"></p> <p><strong>跳过make test 继续执行: make install</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201313267.png" alt="image-20211220131312973"></p> <p>**安装目录：**usr/local/bin</p> <p>查看默认安装目录：</p> <ul><li>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</li> <li>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</li> <li>redis-check-dump：修复有问题的dump.rdb文件</li> <li>redis-sentinel：Redis集群使用</li> <li>redis-server：Redis服务器启动命令</li> <li>redis-cli：客户端，操作入口</li></ul> <p><strong>前台启动（不推荐）</strong></p> <p>前台启动，命令行窗口不能关闭，否则服务器停止</p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201313641.png" alt="image-20211220131325899"></p> <p><strong>后台启动（推荐）</strong></p> <p><strong>备份redis.conf</strong></p> <p>拷贝一份redis.conf到其他目录</p> <p>cp  /opt/redis-3.2.5/redis.conf  /myredis</p> <p><strong>后台启动设置daemonize no改成yes</strong></p> <p>修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动</p> <p><strong>Redis启动</strong></p> <ul><li>redis-server /myredis/redis.conf</li></ul> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201313291.png" alt="image-20211220131338102"></p> <p><strong>用客户端访问：redis-cli</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201313945.png" alt="image-20211220131344744"></p> <p><strong>多个端口可以：redis-cli -p6379</strong></p> <p><strong>测试验证：</strong> <strong>ping</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201313546.png" alt="image-20211220131355089"></p> <p><strong>Redis关闭</strong></p> <ul><li>单实例关闭：redis-cli shutdown</li></ul> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201314719.png" alt="image-20211220131402705"></p> <ul><li>也可以进入终端后再关闭</li></ul> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201314787.png" alt="image-20211220131408713"></p> <p>多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown</p> <h2 id="常用五大数据类型"><a href="#常用五大数据类型" class="header-anchor">#</a> 常用五大数据类型</h2> <h3 id="一、redis-键-key"><a href="#一、redis-键-key" class="header-anchor">#</a> 一、Redis 键（key）</h3> <p>*<em>keys <em>：</em></em> 查看当前库所有key   (匹配：keys *1)</p> <p><strong>exists key：</strong> 判断某个key是否存在</p> <p><strong>type key：</strong> 查看你的key是什么类型</p> <p><strong>del key：</strong> 删除指定的key数据</p> <p><strong>unlink key：</strong> 根据value选择非阻塞删除</p> <ul><li>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li></ul> <p><strong>expire key 10：</strong> 为给定的key设置10秒过期时间</p> <p><strong>ttl key：</strong> 查看还有多少秒过期，<strong>-1表示永不过期，-2表示已过期</strong></p> <hr> <p><strong>select：</strong> 命令切换数据库</p> <p><strong>dbsize：</strong> 查看当前数据库的key的数量</p> <p><strong>flushdb：</strong> 清空当前库</p> <p><strong>flushall：</strong> 通杀全部库</p> <h3 id="二、redis字符串-tring"><a href="#二、redis字符串-tring" class="header-anchor">#</a> 二、Redis字符串（tring）</h3> <p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p> <p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p> <p>**set <code>&lt;key&gt;&lt;value&gt;</code> **添加键值对</p> <ul><li>NX：当数据库中key不存在时，可以将key-value添加数据库</li> <li>XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</li> <li>EX：key的超时秒数</li> <li>PX：key的超时毫秒数，与EX互斥</li></ul> <p>**get  <code>&lt;key&gt;</code>**查询对应键值</p> <hr> <p>**append  <code>&lt;key&gt;&lt;value&gt;</code>**将给定的<code>&lt;value&gt;</code> 追加到原值的末尾</p> <p><strong>strlen  <code>&lt;key&gt;</code></strong> 获得值的长度</p> <p>**setnx  <code>&lt;key&gt;&lt;value&gt;</code>**只有在 key 不存在时   设置 key 的值</p> <p><strong>incr <code>&lt;key&gt;</code></strong> 将 key 中储存的数字值增1</p> <ul><li>只能对数字值操作，如果为空，新增值为1</li></ul> <p>**decr  <code>&lt;key&gt;</code>**将 key 中储存的数字值减1</p> <ul><li>只能对数字值操作，如果为空，新增值为-1</li></ul> <p>**incrby / decrby  <code>&lt;key&gt;&lt;步长&gt;</code>**将 key 中储存的数字值增减。自定义步长。</p> <hr> <p><strong>mset  <code>&lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</code></strong>  .....</p> <ul><li>同时设置一个或多个 key-value对</li></ul> <p><strong>mget  <code>&lt;key1&gt;&lt;key2&gt;&lt;key3&gt;</code></strong> .....</p> <ul><li>同时获取一个或多个 value</li></ul> <p><strong>msetnx <code>&lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</code></strong>  .....</p> <ul><li>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</li> <li><strong>原子性，有一个失败则都失败</strong></li></ul> <hr> <p><strong>getrange  <code>&lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code></strong></p> <ul><li>获得值的范围，类似java中的substring，<strong>前包，后包</strong></li></ul> <p><strong>setrange <code>&lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code></strong></p> <ul><li>用 <code>&lt;value&gt;</code>  覆写<code>&lt;key&gt;</code>所储存的字符串值，从&lt;起始位置&gt;开始(<em>索引从0开始</em>)。</li></ul> <p><strong>setex  <code>&lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code></strong></p> <ul><li>设置键值的同时，设置过期时间，单位秒。</li></ul> <p>getset <code>&lt;key&gt;&lt;value&gt;</code></p> <ul><li>以新换旧，设置了新值同时获得旧值。</li></ul> <hr> <p><strong>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</strong></p> <p>![img](file:///C:\Users\INTELL~1\AppData\Local\Temp\ksohtml\wps36AA.tmp.jpg)</p> <p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p> <h3 id="三、redis-列表-list"><a href="#三、redis-列表-list" class="header-anchor">#</a> 三、Redis 列表（List）</h3> <p><strong>单键多值</strong></p> <p>Redis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p> <p>它的<strong>底层实际是个双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201316744.png" alt="image-20211220131618523"></p> <p><strong>lpush/rpush  <code>&lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt;</code> ....</strong> 从左边/右边插入一个或多个值。</p> <p>**lpop/rpop  <code>&lt;key&gt;</code>**从左边/右边吐出一个值。值在键在，值光键亡。</p> <p>**rpoplpush  <code>&lt;key1&gt;&lt;key2&gt;</code>**从<code>&lt;key1&gt;</code>列表右边吐出一个值，插到<key2>列表左边。</key2></p> <p><strong>lrange <code>&lt;key&gt;&lt;start&gt;&lt;stop&gt;</code></strong></p> <ul><li>按照索引下标获得元素(从左到右)</li></ul> <p><strong>lrange mylist 0 -1</strong>  0左边第一个，-1右边第一个，（0-1表示获取所有）</p> <p>**lindex <code>&lt;key&gt;&lt;index&gt;</code>**按照索引下标获得元素(从左到右)</p> <p>**llen<code>&lt;key&gt;</code>**获得列表长度</p> <p>**linsert <code>&lt;key&gt; before &lt;value&gt;&lt;newvalue&gt;</code>**在<code>&lt;value&gt;</code>的前面插入<code>&lt;newvalue&gt;</code>插入值</p> <p>**lrem <code>&lt;key&gt;&lt;n&gt;&lt;value&gt;</code>**从左边删除n个value(从左到右)</p> <p>**lset<code>&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>**将列表key下标为index的值替换成value</p> <hr> <p><strong>List的数据结构为快速链表quickList。</strong></p> <p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。</p> <p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p> <p>当数据量比较多的时候才会改成quicklist。</p> <p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p> <p><img src="E:/Typora%E5%9B%BE%E7%89%87/image-20211220131629808.png" alt="image-20211220131629808"></p> <p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p> <h3 id="四、redis-集合-set"><a href="#四、redis-集合-set" class="header-anchor">#</a> 四、Redis 集合（Set）</h3> <p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p> <p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的<strong>复杂度都是O(1)</strong>。</p> <hr> <p><strong>sadd <code>&lt;key&gt;&lt;value1&gt;&lt;value2&gt;</code> .....</strong></p> <p>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p> <p>**smembers <code>&lt;key&gt;</code>**取出该集合的所有值。</p> <p>**sismember <code>&lt;key&gt;&lt;value&gt;</code>**判断集合<code>&lt;key&gt;</code>是否为含有该<code>&lt;value&gt;</code>值，有1，没有0</p> <p>**scard<code>&lt;key&gt;</code>**返回该集合的元素个数。</p> <p><strong>srem <code>&lt;key&gt;&lt;value1&gt;&lt;value2&gt;</code></strong> .... 删除集合中的某个元素。</p> <p><strong>spop <code>&lt;key&gt;</code>随机从该集合中吐出一个值。</strong></p> <p>**srandmember <code>&lt;key&gt;&lt;n&gt;</code>**随机从该集合中取出n个值。不会从集合中删除 。</p> <p><strong>smove <code>&lt;source&gt;&lt;destination&gt;</code>value</strong>把集合中一个值从一个集合移动到另一个集合</p> <p><strong>sinter <code>&lt;key1&gt;&lt;key2&gt;</code><strong>返回两个集合的</strong>交集</strong>元素。</p> <p><strong>sunion <code>&lt;key1&gt;&lt;key2&gt;</code><strong>返回两个集合的</strong>并集</strong>元素。</p> <p><strong>sdiff<code>&lt;key1&gt;&lt;key2&gt;</code><strong>返回两个集合的</strong>差集</strong>元素(key1中的，不包含key2中的)</p> <hr> <p>Set数据结构是dict字典，字典是用哈希表实现的。</p> <p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p> <h3 id="五、redis-哈希-hash"><a href="#五、redis-哈希-hash" class="header-anchor">#</a> 五、Redis 哈希（Hash）</h3> <p>Redis hash 是一个键值对集合。</p> <p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p> <p>类似Java里面的Map&lt;String,Object&gt;</p> <p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p> <p>主要有以下2种存储方式：</p> <table><thead><tr><th><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201318310.png" alt="image-20211220131847110"><br>每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</th> <th><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201319661.png" alt="image-20211220131902732"><br>用户ID数据冗余</th></tr></thead> <tbody></tbody></table> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201320627.png" alt="image-20211220132006580"></p> <p>通过**key(用户ID) + field(属性标签)**就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</p> <hr> <p>**hset <code>&lt;key&gt;&lt;field&gt;&lt;value&gt;</code>**给<key>集合中的  <code>&lt;field&gt;</code>键赋值<code>&lt;value&gt;</code></key></p> <p>**hget <code>&lt;key1&gt;&lt;field&gt;</code>从<code>&lt;key1&gt;</code>**集合<code>&lt;field&gt;</code>取出 value</p> <p><strong>hmset <code>&lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;</code>...</strong> 批量设置hash的值</p> <p>**hexists<code>&lt;key1&gt;&lt;field&gt;</code>**查看哈希表 key 中，给定域 field 是否存在。</p> <p>**hkeys <code>&lt;key&gt;</code>**列出该hash集合的所有field</p> <p>**hvals <code>&lt;key&gt;</code>**列出该hash集合的所有value</p> <p>**hincrby <code>&lt;key&gt;&lt;field&gt;&lt;increment&gt;</code>**为哈希表 key 中的域 field 的值加上增量 1  -1</p> <p>**hsetnx <code>&lt;key&gt;&lt;field&gt;&lt;value&gt;</code>**将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</p> <hr> <p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p> <h3 id="六、redis有序集合-zset-sorted-set"><a href="#六、redis有序集合-zset-sorted-set" class="header-anchor">#</a> 六、Redis有序集合（Zset - sorted set）</h3> <p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p> <p>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的，但是评分可以是重复了 。</strong></p> <p>因为元素是有序的, 所以也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p> <p>访问有序集合的中间元素也是非常快的,因此能够使用有序集合作为一个没有重复成员的智能列表。</p> <hr> <p><strong>zadd  <code>&lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;</code>…</strong></p> <ul><li>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li></ul> <p><strong>zrange <code>&lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>  [WITHSCORES]</strong></p> <ul><li>返回有序集 key 中，下标在<code>&lt;start&gt;&lt;stop&gt;</code>之间的元素</li> <li>带WITHSCORES，可以让分数一起和值返回到结果集。</li></ul> <p><strong>zrangebyscore key minmax [withscores] [limit offset count]</strong></p> <ul><li>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</li></ul> <p><strong>zrevrangebyscore key maxmin [withscores] [limit offset count]</strong></p> <ul><li>同上，改为从大到小排列。</li></ul> <p><strong>zincrby <code>&lt;key&gt;&lt;increment&gt;&lt;value&gt;</code></strong>  为元素的score加上增量</p> <p>**zrem  <code>&lt;key&gt;&lt;value&gt;</code>**删除该集合下，指定值的元素</p> <p>**zcount <code>&lt;key&gt;&lt;min&gt;&lt;max&gt;</code>**统计该集合，分数区间内的元素个数</p> <p>**zrank <code>&lt;key&gt;&lt;value&gt;</code>**返回该值在集合中的排名，从0开始。</p> <hr> <p>案例：如何利用zset实现一个文章访问量的排行榜？</p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201320959.png" alt="image-20211220132032169"></p> <hr> <p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p> <p>zset底层使用了两个数据结构</p> <ol><li><strong>hash</strong>，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li> <li><strong>跳跃表</strong>，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li></ol> <h3 id="七、跳跃表-跳表"><a href="#七、跳跃表-跳表" class="header-anchor">#</a> 七、<strong>跳跃表（跳表）</strong></h3> <p>平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p> <p><strong>实例</strong></p> <p>对比有序链表和跳跃表，从链表中查询出51</p> <ul><li>有序链表</li></ul> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201320217.png" alt="image-20211220132044126"></p> <p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p> <ul><li>跳跃表</li></ul> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202112201320872.png" alt="image-20211220132050641"></p> <p>从第2层开始，1节点比51节点小，向后比较。</p> <p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p> <p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p> <p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p> <p>从此可以看出跳跃表比有序链表效率要高</p> <h2 id="bitmap"><a href="#bitmap" class="header-anchor">#</a> BitMap</h2> <p><strong>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是2^32个bit位。</strong></p> <p>BitMap的操作命令有：</p> <ul><li>SETBIT：向指定位置（offset）存入一个0或1GETBIT：获取指定位置（offset）的bit值</li> <li>BITCOUNT：统计BitMap中值为1的bit位的数量</li> <li>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li> <li>BITFIELD_RO：获取BitMap中bit数组，并以十进制形式返回</li> <li>BITOP：将多个BitMap的结果做位运算（与、或、异或）</li> <li>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</li></ul> <h2 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h2> <h3 id="缓存穿透"><a href="#缓存穿透" class="header-anchor">#</a> 缓存穿透</h3> <p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p> <p>大量线程并发请求不存在的数据，使得请求全部进入数据库，可能搞垮数据库。</p> <p><strong>解决方案：</strong></p> <p><strong>1、缓存空对象</strong></p> <ul><li>优点：实现简单，维护方便</li> <li>缺点：
<ul><li>额外的内存消耗</li> <li>可能造成短期的不一致</li></ul></li> <li><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204281437236.png" alt="image-20220428143715229" style="zoom:50%;"></li></ul> <p><strong>2、布隆过滤</strong></p> <ul><li>优点：内存占用较少，没有多余key</li> <li>缺点：
<ul><li>实现复杂</li> <li>存在误判</li></ul></li> <li><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204281437417.png" alt="image-20220428143751858" style="zoom:50%;"></li></ul> <p><strong>3、其他解决方案</strong></p> <ul><li>增强id的复杂度，避免被猜测id规律</li> <li>做好数据的基础格式校验</li> <li>加强用户权限校验</li> <li>做好热点参数的限流</li></ul> <h3 id="缓存雪崩"><a href="#缓存雪崩" class="header-anchor">#</a> 缓存雪崩</h3> <p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务启机，导致大量请求到达数据库，带来巨大压力。</p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204281433460.png" alt="image-20220428143334259" style="zoom:50%;"> <p><strong>解决方案：</strong></p> <ul><li>给不同的Key的TTL添加随机值</li> <li>利用Redis集群提高服务的可用性</li> <li>给缓存业务添加降级限流策略</li> <li>给业务添加多级缓存</li></ul> <h3 id="缓存击穿"><a href="#缓存击穿" class="header-anchor">#</a> 缓存击穿</h3> <p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204281447480.png" alt="image-20220428144727813" style="zoom:50%;"> <p><strong>解决方案：</strong></p> <p><strong>1、互斥锁</strong></p> <p>问题：大量线程阻塞、等待</p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204281448386.png" alt="image-20220428144848828" style="zoom:50%;"> <p><strong>2、逻辑过期</strong></p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204281451775.png" alt="image-20220428145146912" style="zoom:50%;"> <p><strong>对比：</strong></p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204281452842.png" alt="image-20220428145216509" style="zoom:50%;"> <h4 id="实现互斥锁"><a href="#实现互斥锁" class="header-anchor">#</a> 实现互斥锁</h4> <p>redis 的 <code>setnx key value</code> 命令，仅当 key 存在时才能成功，返回1，否则失败，返回 0</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">truLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Boolean</span> flag <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> timeout<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">BooleanUtil</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="分布式锁"><a href="#分布式锁" class="header-anchor">#</a> 分布式锁</h2> <h3 id="全局唯一id"><a href="#全局唯一id" class="header-anchor">#</a> 全局唯一ID</h3> <p>一般需要满足以下特性：</p> <ul><li>唯一性</li> <li>高可用</li> <li>高性能</li> <li>递增性</li> <li>安全性</li></ul> <h4 id="全局id生成器"><a href="#全局id生成器" class="header-anchor">#</a> 全局ID生成器</h4> <p><strong>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204290057439.png" alt="image-20220429005728598"></p> <p>组成：</p> <ul><li>符号位：1bit，永远为 0</li> <li>时间戳：21bit，以秒为单位，可以使用 69 年</li> <li>序列号，32bit，秒内的计数器，支持每秒产生 $2^{32}$ 个不同ID</li></ul> <h3 id="秒杀业务"><a href="#秒杀业务" class="header-anchor">#</a> 秒杀业务</h3> <p>下单时需要判断两点：</p> <ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li> <li>库存是否充足，不足则无法下单</li></ul> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204290102343.png" alt="image-20220429010034893" style="zoom:80%;"> <h3 id="超卖问题"><a href="#超卖问题" class="header-anchor">#</a> 超卖问题</h3> <p><strong>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：</strong></p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204290102243.png" alt="image-20220429010235408" style="zoom:67%;"> <h4 id="乐观锁"><a href="#乐观锁" class="header-anchor">#</a> 乐观锁</h4> <h5 id="版本号法"><a href="#版本号法" class="header-anchor">#</a> 版本号法</h5> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/7cb2d56788634486bcbdde56678c4a63-image-20220429010418891.png" alt="image-20220429010418891" style="zoom:80%;"> <h5 id="cas-法"><a href="#cas-法" class="header-anchor">#</a> CAS 法</h5> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/49db6f4ca5cf46df8ab545bd15d73042-image-20220429010528363.png" alt="image-20220429010528363" style="zoom:80%;"> <p>对比：</p> <ul><li>悲观锁：添加同步锁，让线程串行执行优点：简单粗暴缺点：性能一般</li> <li>乐观锁：不加锁，在更新时判断是否有其它线程在修改
<ul><li>优点：性能好</li> <li>缺点：存在成功率低的问题（通过库存余量是否大于零控制）</li></ul></li></ul> <h3 id="一人一单"><a href="#一人一单" class="header-anchor">#</a> 一人一单</h3> <p><strong>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</strong></p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291131370.png" alt="image-20220429113051843" style="zoom:80%;"> <p>先查询订单，再判断用户订单是否存在，还是会出现线程问题。新增数据无法使用乐观锁，因此给查询、判断、新增都加上悲观锁。</p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291134226.png" alt="image-20220429113414723" style="zoom:50%;"> <p>在集群模式下，synchronized 就不起作用了，因为它只在一个 JVM 实例中，不同服务会有不同的 JVM 实例。</p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291136962.png" alt="image-20220429113638677" style="zoom:50%;"> <h3 id="分布式锁-2"><a href="#分布式锁-2" class="header-anchor">#</a> 分布式锁</h3> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291137853.png" alt="image-20220429113743598"> <p>分布式锁：满足分布式系统或集群模式下多进程可见并互斥的锁</p> <ul><li>多进程可见</li> <li>互斥</li> <li>高可用</li> <li>高性能</li> <li>安全性</li></ul> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291139181.png" alt="image-20220429113944588" style="zoom:50%;"> <h4 id="实现分布式锁"><a href="#实现分布式锁" class="header-anchor">#</a> 实现分布式锁</h4> <p><strong>获取锁</strong></p> <ul><li><p>互斥：确保只有一个线程能获取锁</p> <p><code>SETNX lock thread1</code></p> <p><code>EXPIRE lock 10</code></p></li> <li><p>非阻塞：尝试一次，成功返回 true，失败返回 false</p></li></ul> <p><strong>获取锁，和添加过期时间必须保证原子性，因此修改为一个命令：</strong></p> <p><code>SET lock thread1 NX EX 10</code></p> <p><strong>释放锁</strong></p> <ul><li><p>手动释放</p></li> <li><p>超时释放：获取锁时添加一个超时时间</p> <p><code>DEL key</code></p></li></ul> <h4 id="误删问题"><a href="#误删问题" class="header-anchor">#</a> 误删问题</h4> <p><strong>线程一获取锁之后阻塞了，超过了redis超时释放锁的时间，业务完成后就会误删其他线程的锁。</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291152928.png" alt="image-20220429114906585"></p> <p><strong>解决方案：</strong></p> <ol><li>在获取锁时存入线程标识（可以用UUID表示）</li> <li>在释放锁时先获取锁中的线程标示，判断是否与当前线程一致
<ul><li>如果一致则释放锁</li> <li>如果不一致则不释放锁</li></ul></li></ol> <h4 id="原子性问题"><a href="#原子性问题" class="header-anchor">#</a> 原子性问题</h4> <p><strong>线程一判断锁标识是否一致之后，阻塞了，也可能会误删其他线程的锁。</strong></p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291157557.png" alt="image-20220429115736863" style="zoom:50%;"> <p><strong>因此判断锁标识和释放锁必须是原子操作</strong></p> <h3 id="lua-脚本"><a href="#lua-脚本" class="header-anchor">#</a> Lua 脚本</h3> <p><strong>Redis 提供的脚本，可以在一个脚本中编写多条 Redis 命令，确保多条命令原子执行。</strong></p> <p>释放锁的业务流程：</p> <ol><li>获取锁中的线程标示</li> <li>判断是否与指定的标示（当前线程标示）一致</li> <li>如果一致则释放锁（删除）</li> <li>如果不一致则什么都不做</li></ol> <p><strong>如果用Lua脚本来表示则是这样的：</strong></p> <div class="language-lua extra-class"><pre class="language-lua"><code><span class="token comment">-- 这里的KEYS[1]就是锁的key，这里的ARGV[1]就是当前线程标示</span>
<span class="token comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">then</span>
    <span class="token comment">-- 一致</span>
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'DEL'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token comment">-- 不一致，则直接返回</span>
<span class="token keyword">return</span> <span class="token number">0</span>
</code></pre></div><p>使用 java 执行脚本</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 初始化脚本</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> UNLOCK_SCRIPT<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token punctuation">{</span>
    UNLOCK_SCRIPT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    UNLOCK_SCRIPT<span class="token punctuation">.</span><span class="token function">setLocation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span><span class="token string">&quot;unlock.lua&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    UNLOCK_SCRIPT<span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>
        UNLOCK_SCRIPT<span class="token punctuation">,</span>
        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>KEY_PREFIX <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">,</span>
        ID_PREFIX <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="redisson"><a href="#redisson" class="header-anchor">#</a> Redisson</h2> <p><strong>基于setnx实现的分布式锁存在下面的问题：</strong></p> <ol><li>**不可重入：**同一个线程无法多次获取同一把锁</li> <li>**不可重试：**获取锁只尝试一次就返回false，没有重试机制</li> <li>**超时释放：**锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患</li> <li>**主从一致性：**如果Redis提供了主从集群，主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现</li></ol> <p><strong>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现：</strong></p> <ul><li>可重入锁</li> <li>公平锁</li> <li>联锁</li> <li>红锁</li> <li>读写锁</li> <li>信号量</li> <li>可过期性信号量</li> <li>闭锁</li></ul> <p><a href="https://redisson.org" target="_blank" rel="noopener noreferrer">官网地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://github.com/redisson/redisson" target="_blank" rel="noopener noreferrer">Github<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="redisson-入门"><a href="#redisson-入门" class="header-anchor">#</a> Redisson 入门</h3> <p>1、引入依赖</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.13.6&lt;/version
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>2、配置 Redisson 客户端：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">RedissonClient</span> <span class="token function">redissonClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 配置类</span>
        <span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">&quot;ip&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">&quot;password&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Redisson</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>3、使用 Redisson 的分布式锁</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Resource</span>
<span class="token keyword">private</span> <span class="token class-name">RedissonClient</span> redissonClient<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Test</span>
<span class="token keyword">void</span> <span class="token function">testRedisson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取锁（可重入），指定锁的名称</span>
    <span class="token class-name">Rlock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">&quot;anyLock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 尝试获取锁，参数分别是：获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位</span>
    <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span><span class="token punctuation">(</span>isLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//...</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 释放锁</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="redisson-可重入锁原理"><a href="#redisson-可重入锁原理" class="header-anchor">#</a> Redisson 可重入锁原理</h3> <p><strong>类似于 ReenternLock 的原理，判断当前锁是否已被获取，如果已被获取，判断锁的标识是否为当前线程，是的话也会让它获取锁。</strong></p> <p>增加了计数器，每当线程重入一次，计数器就加一；线程结束则计数器减一，当计数器减到零，就释放锁。</p> <p>使用 Redis 中的 hash 结构，存储:</p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291527694.png" alt="image-20220429152548189" style="zoom:50%;"> <p><strong>可重入锁获取与释放流程：</strong></p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291527645.png" alt="image-20220429152724608" style="zoom:50%;"> <h4 id="获取锁的-lua-脚本"><a href="#获取锁的-lua-脚本" class="header-anchor">#</a> 获取锁的 Lua 脚本：</h4> <div class="language-lua extra-class"><pre class="language-lua"><code><span class="token keyword">local</span> key <span class="token operator">=</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">--锁的key </span>
<span class="token keyword">local</span> threadId <span class="token operator">=</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">-- 线程唯一标识</span>
<span class="token keyword">local</span> releaseTime <span class="token operator">=</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">-- 锁的自动释放时间</span>
<span class="token comment">-- 判断是否存在</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'exists'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">==</span> O<span class="token punctuation">)</span> <span class="token keyword">then</span>
    <span class="token comment">-- 不存在，获取锁</span>
	redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hset'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">--设置有效期</span>
	redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'expire'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> releaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">--返回结果</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>
<span class="token comment">-- 锁已经存在，判断threadId是否是自己</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hexists'</span><span class="token punctuation">,</span> key，threadId<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">then</span>
    <span class="token comment">-- 不存在，获取锁，重人次数+1</span>
	redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hincrby'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">-- 设置有效期</span>
	redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'expire'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> releaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">-- 返回结果</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> O<span class="token punctuation">;</span> <span class="token comment">--代码走到这里，说明获取锁的不是自己，获取锁失败</span>
</code></pre></div><h4 id="释放锁的-lua-脚本"><a href="#释放锁的-lua-脚本" class="header-anchor">#</a> 释放锁的 Lua 脚本</h4> <div class="language-lua extra-class"><pre class="language-lua"><code><span class="token keyword">local</span> key <span class="token operator">=</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">--锁的key</span>
<span class="token keyword">local</span> threadId <span class="token operator">=</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">--线程唯一标识</span>
<span class="token keyword">local</span> releaseTime <span class="token operator">=</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">-- 锁的自动释放时间</span>
<span class="token comment">-- 判断当前锁是否还是被自己持有</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'HEXISTS'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span> <span class="token operator">==</span> Ο<span class="token punctuation">)</span> <span class="token keyword">then</span>
    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span> <span class="token comment">--如果已经不是自己，则直接返回</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>
<span class="token comment">-- 是自己的锁，则重入次数-1</span>
<span class="token keyword">local</span> count <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'HINCRBY'</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>threadId<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 判断是否重人次数是否已经为0</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;</span> O<span class="token punctuation">)</span> <span class="token keyword">then</span>
    <span class="token comment">-- 大于0说明不能释放锁，重置有效期然后返回</span>
	redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'EXPIRE'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> releaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token comment">--等于O说明可以释放锁，直接删除</span>
	redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'DEL'</span>，key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="redisson-可重试原理"><a href="#redisson-可重试原理" class="header-anchor">#</a> Redisson 可重试原理</h3> <p><strong>利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</strong></p> <p>Redisson 的 lua 脚本，获取锁成功，返回nil；获取锁失败，返回锁的剩余有效期。</p> <p><strong>重试流程：</strong></p> <ol><li><p>判断是否在有效期内，如果在剩余有效期内，则开启重试流程</p></li> <li><p>订阅释放锁的信号 <code>RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</code></p> <p>释放锁脚本中会释放锁：<code>redis.call('publish', KEYS[2], ARGV[1]);</code></p></li> <li><p>等待直到剩余有效时间结束</p></li> <li><p>如果还没有结束，则重新判断有效期，并进入等待。</p></li></ol> <h3 id="redisson-超时续约原理"><a href="#redisson-超时续约原理" class="header-anchor">#</a> Redisson 超时续约原理</h3> <p><strong>利用watchDog，每隔一段时间（releaseTime /3），重置超时时间</strong></p> <ol><li><p>要确保锁是业务执行完才释放，而不是超时了释放。因此 Redisson 会在尝试获取锁的时候，判断有没有设置超时时间，如果没有设置，则默认使用看门狗超时时间（30s）</p></li> <li><p>获取锁，返回剩余时间ttlRemaining等于null，则获取锁成功</p></li> <li><p>更新续期 scheduleExpirationRenewal(threadId)</p> <ul><li><p>RedissonLock 类中有一个static final 的 ConcurrentMap：<strong>EXPIRATION_RENEWAL_MAP</strong>，所有线程实例的锁都可以放到这个 map 中。</p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291736381.png" alt="image-20220429173651026"></p></li> <li><p>putIfAbsent 放入新的锁，则返回 null；如果放入的锁已经存在了，则返回旧的锁</p></li> <li><p>如果来的是新的锁，则进行续约操作，更新有效期</p></li> <li><p><strong>renewExpiration 会创建一个 Timeout 任务，在看门狗 / 3 (10s) 后执行，执行lua脚本刷新有效时间。并递归调用自身，在 10 秒后继续刷新。</strong></p></li></ul></li> <li><p>当释放锁之后，会调用取消刷新任务：</p> <ul><li>从 <strong>EXPIRATION_RENEWAL_MAP</strong> 中取出当前锁，计数器 - 1，取消 Timeout 任务，把 <strong>EXPIRATION_RENEWAL_MAP</strong> 中的当前锁 remove 掉</li></ul></li></ol> <h3 id="整体流程图"><a href="#整体流程图" class="header-anchor">#</a> 整体流程图</h3> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204291613655.png" alt="image-20220429161321075"></p> <h3 id="联锁"><a href="#联锁" class="header-anchor">#</a> 联锁</h3> <p><strong>对于集群的每个节点都保存锁，获取锁的时候必须判断其他节点都没有获取锁，才能拿到。解决了主从一致性导致的锁失效的问题</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">RLock</span> lock<span class="token punctuation">;</span>

<span class="token annotation punctuation">@BeforeEach</span> 
<span class="token keyword">void</span> <span class="token function">setUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">RLock</span> lockl <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>name：<span class="token string">&quot;order&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">RLock</span> lock2 <span class="token operator">=</span> redissonClien2<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>name：<span class="token string">&quot;order&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">RLock</span> lock3 <span class="token operator">=</span> redissonClien3<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>name：<span class="token string">&quot;order&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token comment">//创建联锁 multiLock </span>
    lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getMultiLock</span><span class="token punctuation">(</span>lockl，lock2，lock3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="优化秒杀业务"><a href="#优化秒杀业务" class="header-anchor">#</a> 优化秒杀业务</h2> <p><strong>因为添加了很多分布式锁，因此秒杀业务的性能会受到很大影响，因此需要做进一步优化</strong></p> <p>需求：</p> <ol><li>新增秒杀优惠卷同时，将优惠卷信息保存到 Redis 中</li> <li>基于 Lua 脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</li> <li>如果抢购成功，将优惠卷 id 和用户 id 封装后存入阻塞队列</li> <li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ol> <h2 id="redis消息队列"><a href="#redis消息队列" class="header-anchor">#</a> Redis消息队列</h2> <h3 id="list-模拟消息队列"><a href="#list-模拟消息队列" class="header-anchor">#</a> List 模拟消息队列</h3> <p><strong>使用 <code>BLPUSH</code> 和 <code>BRPOP</code> 来实现阻塞效果</strong></p> <p><strong>优点：</strong></p> <ul><li>利用Redis存储，不受限于JVM内存上限</li> <li>基于Redis的持久化机制，数据安全性有保证</li> <li>可以满足消息有序性</li></ul> <p><strong>缺点：</strong></p> <ul><li>无法避免消息丢失</li> <li>只支持单消费者</li></ul> <h3 id="基于-pubsub-的消息队列"><a href="#基于-pubsub-的消息队列" class="header-anchor">#</a> 基于 PubSub 的消息队列</h3> <p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，<strong>消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</strong>。</p> <ul><li>**SUBSCRIBE channel[channel]：**订阅一个或多个频道</li> <li>**PUBLISH channel nisg：**向一个频道发送消息</li> <li>**PSUBSCRIBE pattern[pattern]：**订阅与pattern格式匹配的所有频道</li></ul> <p><strong>优点：</strong></p> <ul><li>采用发布订阅模型，支持多生产、多消费</li></ul> <p><strong>缺点：</strong></p> <ul><li>不支持数据持久化</li> <li>无法避免消息丢失</li> <li>消息堆积有上限，超出时数据丢失</li></ul> <h3 id="基于-stream-的消息队列"><a href="#基于-stream-的消息队列" class="header-anchor">#</a> 基于 Stream 的消息队列</h3> <p><strong>Stream 是Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</strong></p> <p><strong>发消息：XADD</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204292310788.png" alt="image-20220429231000782"></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204292310823.png" alt="image-20220429231040778"></p> <p><strong>读消息的方式之一：XREAD</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202204292314224.png" alt="image-20220429231358391"></p> <p><strong>阻塞方式读取最新的消息：</strong> <code>XREAD COUNT 1 BLOCK 0 STREAMS s1 $</code>，最多读取一条消息，永久阻塞，读取s1的最新消息</p> <p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尝试读取队列中的消息，最多阻塞2秒</span>
    <span class="token class-name">Object</span> msg <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token string">&quot;XREAD COUNT 1 BLOCK 2000 STREAMS users $&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>msg <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 处理消息</span>
    <span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>**注意：**当我们指定起始ID为$时，代表读取最新的消息，<strong>如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题。</strong></p> <hr> <p><strong>STREAM类型消息队列的XREAD命令特点：</strong></p> <ul><li>消息可回溯</li> <li>一个消息可以被多个消费者读取</li> <li>可以阻塞读取</li> <li>有消息漏读的风险</li></ul> <h3 id="基于-stream-的消息队列-消费者组"><a href="#基于-stream-的消息队列-消费者组" class="header-anchor">#</a> 基于 Stream 的消息队列——消费者组</h3> <p><strong>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</strong></p> <ol><li><p><strong>消费分流</strong></p> <p>队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度</p></li> <li><p><strong>消费标识</strong></p> <p>消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者启机重启，还会从标示之后读取消息。确保每一个消息都会被消费</p></li> <li><p><strong>消息确认</strong></p> <p>消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-List移除。</p></li></ol> <h4 id="创建消费者组"><a href="#创建消费者组" class="header-anchor">#</a> 创建消费者组</h4> <div class="language-bash extra-class"><pre class="language-bash"><code>XGROUP CREATE key groupName ID <span class="token punctuation">[</span>MKSTREAM<span class="token punctuation">]</span>
</code></pre></div><ul><li>**key：**队列名称</li> <li>**groupName：**消费者组名称</li> <li>**ID：**起始ID标示，$代表队列中最后一个消息，o则代表队列中第一个消息</li> <li>**MKSTREAM：**队列不存在时自动创建队列</li></ul> <p><strong>其他常见命令：</strong></p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205031403504.png" alt="image-20220503140256150" style="zoom:50%;"> <h4 id="从消费者组读取消息"><a href="#从消费者组读取消息" class="header-anchor">#</a> 从消费者组读取消息</h4> <div class="language-bash extra-class"><pre class="language-bash"><code>XREADGROUP GROUP group consumer <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span> <span class="token punctuation">[</span>BLOCK milliseconds<span class="token punctuation">]</span> <span class="token punctuation">[</span>NOACK<span class="token punctuation">]</span> STREAMS key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> ID <span class="token punctuation">[</span>ID <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre></div><ul><li>**group：**消费组名称</li> <li>**consumer：**消费者名称，如果消费者不存在，会自动创建一个消费者count：本次查询的最大数量</li> <li>**BLOCK milliseconds：**当没有消息时最长等待时间NOACK：无需手动ACK，获取到消息后自动确认</li> <li>**STREAMS key：**指定队列名称</li> <li>**ID：**获取消息的起始ID：
<ul><li>**&quot;&gt;&quot;：**从下一个未消费的消息开始</li> <li>**其它：**根据指定idMpending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li></ul></li></ul> <p><strong>例：创建和读取</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205031413725.png" alt="image-20220503141357291"></p> <p>没有确认的消息则进入 Pending List 中</p> <p><strong>确认消息和查看 Pending List</strong></p> <p><code>- + 10</code> 表示从最小到最大的 10 个 id</p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205031417869.png" alt="image-20220503141655657" style="zoom:50%;"> <p><strong>读取 Pending List 中的第一条消息（把 &gt; 改成 0）并确认：</strong></p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205031421537.png" alt="image-20220503142118746" style="zoom:50%;"> <p><strong>java代码处理消费者组逻辑：</strong></p> <ol><li>先去消费者组里读取消息，没读到就循环继续读</li> <li>读到了，处理消息，确认消息</li> <li>如果处理消息的过程中发生异常，没有确认消息，则从Pending List中读取消息</li> <li>读取到消息，重新处理，否则一直循环</li></ol> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205031426758.png" alt="image-20220503142603965" style="zoom:67%;"> <h4 id="stream类型消息队列的xreadgroup命令特点"><a href="#stream类型消息队列的xreadgroup命令特点" class="header-anchor">#</a> STREAM类型消息队列的XREADGROUP命令特点：</h4> <ul><li>消息可回溯</li> <li>可以多消费者争抢消息，加快消费速度</li> <li>可以阻塞读取</li> <li>没有消息漏读的风险</li> <li>有消息确认机制，保证消息至少被消费一次</li></ul> <h3 id="redis-消息队列总结"><a href="#redis-消息队列总结" class="header-anchor">#</a> Redis 消息队列总结</h3> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205031429447.png" alt="image-20220503142954711" style="zoom:50%;"> <h2 id="分布式缓存"><a href="#分布式缓存" class="header-anchor">#</a> 分布式缓存</h2> <ul><li>Redis 持久化</li> <li>Redis 主从</li> <li>Redis 哨兵</li> <li>Redis 分片集群</li></ul> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/677ddf9de56c4df8b14e166d40e4db93-image-20220504194515086.png" alt="image-20220504194515086" style="zoom:33%;"> <h3 id="redis-持久化"><a href="#redis-持久化" class="header-anchor">#</a> Redis 持久化</h3> <h4 id="rdb-持久化"><a href="#rdb-持久化" class="header-anchor">#</a> RDB 持久化</h4> <p><strong>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</strong></p> <p><strong>命令：</strong></p> <p><code>sava</code>：在主进程中执行，因此会阻塞所有命令，不推荐使用。</p> <p><code>bgsave</code>：开启子进程执行，避免主进程受到影响</p> <p><strong>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</strong></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 900秒内，如果至少有1个key被修改，则执行bgsave，如果是save&quot;&quot;则表示禁用RDB</span>
save <span class="token number">900</span> <span class="token number">1</span>
save <span class="token number">300</span> <span class="token number">10</span>
save <span class="token number">60</span> <span class="token number">10000</span>
</code></pre></div><p><strong>RDB的其它配置也可以在redis.conf文件中设置：</strong></p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 是否压缩，建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span>
rdbcompression <span class="token function">yes</span>

<span class="token comment"># RDB文件名称</span>
dbfilename dump.rdb

<span class="token comment"># 文件保存的路径目录</span>
dir./
</code></pre></div><h5 id="rdb-的-fork-原理"><a href="#rdb-的-fork-原理" class="header-anchor">#</a> RDB 的 fork 原理</h5> <p>bgsave 开始时会 fork 主进程得到子进程，子进程<strong>共享</strong>主进程的内存数据。完成 fork 后读取内存数据并写入RDB 文件。</p> <blockquote><p>Linux 的进程无法直接操作物理内存，而是cpu 分配一个虚拟内存。主进程 fork 的时候，把虚拟内存的页表拷贝给子进程，从而可以操作同一个物理内存。</p></blockquote> <p>fork 采用的是 copy-on-write 技术：</p> <ul><li>当主进程执行读操作时，访问共享内存；</li> <li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205042010729.png" alt="image-20220504201036057" style="zoom:50%;"> <h5 id="总结"><a href="#总结" class="header-anchor">#</a> 总结：</h5> <p><strong>RDB方式bgsave的基本流程？</strong></p> <ul><li>fork主进程得到一个子进程，共享内存空间</li> <li>子进程读取内存数据并写入新的RDB文件</li> <li>用新RDB文件替换旧的RDB文件</li></ul> <p><strong>RDB会在什么时候执行？save 60 1000代表什么含义？</strong></p> <ul><li>默认是服务停止时。</li> <li>代表60秒内至少执行1000次修改则触发</li></ul> <p><strong>RDB RDB的缺点？</strong></p> <ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li> <li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul> <h4 id="aof-持久化"><a href="#aof-持久化" class="header-anchor">#</a> AOF 持久化</h4> <p><strong>AOF全称为 Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</strong></p> <p>AOF 默认是关闭的，需要修改 redis.conf 配置文件来开启：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 是否开启AOF功能，默认是no </span>
appendonly <span class="token function">yes</span>
<span class="token comment"># AOF文件的名称</span>
appendfilename <span class="token string">&quot;appendonly.aof&quot;</span>
</code></pre></div><p>AOF 的命令记录频率也可以通过 redis.conf 文件来配：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment">#表示每执行一次写命令，立即记录到AOF文件</span>
appendfsync always
<span class="token comment">#写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span>
appendfsync everysec
<span class="token comment">#写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span>
appendfsync no
</code></pre></div><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行 <strong>bgrewriteaof</strong> 命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205042023568.png" alt="image-20220504202249948" style="zoom:50%;"> <p>Redis也会在触发阅值时自动去重写AOF文件。阅值也可以在redis.conf中配置：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment">#AOF文件比上次文件 增长超过多少百分比则触发重写</span>
auto-aof-rewrite-percentage <span class="token number">100</span>
<span class="token comment">#AOF文件体积最小多大以上才触发重写</span>
auto-aof-rewrite-min-size 64mb
</code></pre></div><h4 id="rdb-与-aof-对比"><a href="#rdb-与-aof-对比" class="header-anchor">#</a> RDB 与 AOF 对比</h4> <p><strong>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。</strong></p> <table><thead><tr><th></th> <th>RDB</th> <th>AOF</th></tr></thead> <tbody><tr><td><strong>持久化方式</strong></td> <td>定时对整个内存做快照</td> <td>记录每一次执行的命令</td></tr> <tr><td><strong>数据完整性</strong></td> <td>不完整，两次备份之间会丢失</td> <td>相对完整，取决于刷盘策略</td></tr> <tr><td><strong>文件大小</strong></td> <td>会有压缩，文件体积小</td> <td>记录命令，文件体积很大</td></tr> <tr><td><strong>宕机恢复速度</strong></td> <td>很快</td> <td>慢</td></tr> <tr><td><strong>数据恢复优先级</strong></td> <td>低，因为数据完整性不如AOF</td> <td>高，因为数据完整性更高</td></tr> <tr><td><strong>系统资源占用</strong></td> <td>高，大量CPU和内存消耗</td> <td>低，主要是磁盘IO资源，但AOF重写时会占用大量CPU和内存资源</td></tr> <tr><td><strong>使用场景</strong></td> <td>可以容忍数分钟的数据丢失，追求更快的启动速度</td> <td>对数据安全性要求较高常见</td></tr></tbody></table> <h3 id="redis-主从"><a href="#redis-主从" class="header-anchor">#</a> Redis 主从</h3> <p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p> <img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205042035461.png" alt="image-20220504203513467" style="zoom:50%;"> <h4 id="开启主从关系"><a href="#开启主从关系" class="header-anchor">#</a> 开启主从关系：</h4> <p>使用replicaof或者slaveof（5.0以前）命令，有临时和永久两种模式：</p> <ul><li>修改配置文件（永久生效）
<ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li> <li>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）
<ul><li><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li></ul> <p><strong>查看主从信息：</strong><code>INFO replication</code></p> <h4 id="数据同步原理"><a href="#数据同步原理" class="header-anchor">#</a> 数据同步原理</h4> <p><strong>主从第一次同步时全量同步：</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205062246488.png" alt="image-20220506224634344"></p> <p><strong>master如何判断slave是不是第一次来同步数据？这里会用到两个很重要的概念：</strong></p> <ul><li>**Replication Id：**简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li> <li>**offset：**偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。
<strong>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据</strong></li></ul> <p><strong>master如何判断slave节点是不是第一次来做数据同步？</strong></p> <p>判断 replid 是否与主节点一致</p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205062250984.png" alt="image-20220506225034873"></p> <p><strong>总结：</strong></p> <p>全量同步流程：</p> <ol><li>slave节点请求增量同步</li> <li>master节点判断replid，发现不一致，拒绝增量同步</li> <li>master将完整内存数据生成RDB，发送RDB到slave</li> <li>slave清空本地数据，加载master的RDB master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li> <li>slave执行接收到的命令，保持与master之间的同步</li></ol> <p><strong>增量同步：</strong></p> <p>主从第一次同步是全量同步，但如果slave重启后同步，则执行<strong>增量同步</strong></p> <p><img src="https://typora-img-1307960409.cos.ap-shanghai.myqcloud.com/img/202205062257401.png" alt="image-20220506225702464"></p> <p><strong>repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于log做增量同步，只能再次全量同步。</strong></p> <p><strong>可以从以下几个方面来优化Redis主从就集群：</strong></p> <ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li> <li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li> <li>适当提高repl_baklog的大小，发现slave启机时尽快实现故障恢复，尽可能避免全量同步</li> <li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul> <h4 id="总结全量同步和增量同步"><a href="#总结全量同步和增量同步" class="header-anchor">#</a> 总结全量同步和增量同步</h4> <p><strong>简述全量同步和增量同步区别？</strong></p> <ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li> <li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul> <p><strong>什么时候执行全量同步？</strong></p> <ul><li>slave节点第一次连接master节点时</li> <li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul> <p><strong>什么时候执行增量同步？</strong></p> <ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/views/Java/Redis.html#redis安装" class="sidebar-link reco-side-redis安装" data-v-70334359>Redis安装</a></li><li class="level-2" data-v-70334359><a href="/views/Java/Redis.html#常用五大数据类型" class="sidebar-link reco-side-常用五大数据类型" data-v-70334359>常用五大数据类型</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#一、redis-键-key" class="sidebar-link reco-side-一、redis-键-key" data-v-70334359>一、Redis 键（key）</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#二、redis字符串-tring" class="sidebar-link reco-side-二、redis字符串-tring" data-v-70334359>二、Redis字符串（tring）</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#三、redis-列表-list" class="sidebar-link reco-side-三、redis-列表-list" data-v-70334359>三、Redis 列表（List）</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#四、redis-集合-set" class="sidebar-link reco-side-四、redis-集合-set" data-v-70334359>四、Redis 集合（Set）</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#五、redis-哈希-hash" class="sidebar-link reco-side-五、redis-哈希-hash" data-v-70334359>五、Redis 哈希（Hash）</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#六、redis有序集合-zset-sorted-set" class="sidebar-link reco-side-六、redis有序集合-zset-sorted-set" data-v-70334359>六、Redis有序集合（Zset - sorted set）</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#七、跳跃表-跳表" class="sidebar-link reco-side-七、跳跃表-跳表" data-v-70334359>七、跳跃表（跳表）</a></li><li class="level-2" data-v-70334359><a href="/views/Java/Redis.html#bitmap" class="sidebar-link reco-side-bitmap" data-v-70334359>BitMap</a></li><li class="level-2" data-v-70334359><a href="/views/Java/Redis.html#缓存" class="sidebar-link reco-side-缓存" data-v-70334359>缓存</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#缓存穿透" class="sidebar-link reco-side-缓存穿透" data-v-70334359>缓存穿透</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#缓存雪崩" class="sidebar-link reco-side-缓存雪崩" data-v-70334359>缓存雪崩</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#缓存击穿" class="sidebar-link reco-side-缓存击穿" data-v-70334359>缓存击穿</a></li><li class="level-2" data-v-70334359><a href="/views/Java/Redis.html#分布式锁" class="sidebar-link reco-side-分布式锁" data-v-70334359>分布式锁</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#全局唯一id" class="sidebar-link reco-side-全局唯一id" data-v-70334359>全局唯一ID</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#秒杀业务" class="sidebar-link reco-side-秒杀业务" data-v-70334359>秒杀业务</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#超卖问题" class="sidebar-link reco-side-超卖问题" data-v-70334359>超卖问题</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#一人一单" class="sidebar-link reco-side-一人一单" data-v-70334359>一人一单</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#分布式锁-2" class="sidebar-link reco-side-分布式锁-2" data-v-70334359>分布式锁</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#lua-脚本" class="sidebar-link reco-side-lua-脚本" data-v-70334359>Lua 脚本</a></li><li class="level-2" data-v-70334359><a href="/views/Java/Redis.html#redisson" class="sidebar-link reco-side-redisson" data-v-70334359>Redisson</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#redisson-入门" class="sidebar-link reco-side-redisson-入门" data-v-70334359>Redisson 入门</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#redisson-可重入锁原理" class="sidebar-link reco-side-redisson-可重入锁原理" data-v-70334359>Redisson 可重入锁原理</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#redisson-可重试原理" class="sidebar-link reco-side-redisson-可重试原理" data-v-70334359>Redisson 可重试原理</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#redisson-超时续约原理" class="sidebar-link reco-side-redisson-超时续约原理" data-v-70334359>Redisson 超时续约原理</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#整体流程图" class="sidebar-link reco-side-整体流程图" data-v-70334359>整体流程图</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#联锁" class="sidebar-link reco-side-联锁" data-v-70334359>联锁</a></li><li class="level-2" data-v-70334359><a href="/views/Java/Redis.html#优化秒杀业务" class="sidebar-link reco-side-优化秒杀业务" data-v-70334359>优化秒杀业务</a></li><li class="level-2" data-v-70334359><a href="/views/Java/Redis.html#redis消息队列" class="sidebar-link reco-side-redis消息队列" data-v-70334359>Redis消息队列</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#list-模拟消息队列" class="sidebar-link reco-side-list-模拟消息队列" data-v-70334359>List 模拟消息队列</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#基于-pubsub-的消息队列" class="sidebar-link reco-side-基于-pubsub-的消息队列" data-v-70334359>基于 PubSub 的消息队列</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#基于-stream-的消息队列" class="sidebar-link reco-side-基于-stream-的消息队列" data-v-70334359>基于 Stream 的消息队列</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#基于-stream-的消息队列-消费者组" class="sidebar-link reco-side-基于-stream-的消息队列-消费者组" data-v-70334359>基于 Stream 的消息队列——消费者组</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#redis-消息队列总结" class="sidebar-link reco-side-redis-消息队列总结" data-v-70334359>Redis 消息队列总结</a></li><li class="level-2" data-v-70334359><a href="/views/Java/Redis.html#分布式缓存" class="sidebar-link reco-side-分布式缓存" data-v-70334359>分布式缓存</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#redis-持久化" class="sidebar-link reco-side-redis-持久化" data-v-70334359>Redis 持久化</a></li><li class="level-3" data-v-70334359><a href="/views/Java/Redis.html#redis-主从" class="sidebar-link reco-side-redis-主从" data-v-70334359>Redis 主从</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div></div><div class="kanbanniang" data-v-5775ee02><div class="banniang-container" style="display:;" data-v-5775ee02><div class="messageBox" style="right:8px;bottom:210px;display:none;" data-v-5775ee02>
      欢迎来到 Coloring
    </div> <div class="operation" style="right:8px;bottom:50px;display:none;" data-v-5775ee02><i class="kbnfont kbn-ban-home ban-home" data-v-5775ee02></i> <i class="kbnfont kbn-ban-message message" data-v-5775ee02></i> <i class="kbnfont kbn-ban-close close" data-v-5775ee02></i> <a target="_blank" href="https://vuepress-theme-reco.recoluan.com/views/plugins/kanbanniang.html" data-v-5775ee02><i class="kbnfont kbn-ban-info info" data-v-5775ee02></i></a> <i class="kbnfont kbn-ban-theme skin" style="display:;" data-v-5775ee02></i></div> <canvas id="banniang" width="150" height="220" class="live2d" style="right:50px;bottom:0px;opacity:1.0;" data-v-5775ee02></canvas></div> <div class="showBanNiang" style="display:none;" data-v-5775ee02>
    看板娘
  </div></div><APlayer audio="" fixed="true" mini="true" autoplay="autoplay" theme="#FFB6C1" loop="loop" order="list" preload="auto" volume="0.1" mutex="true" lrc-type="0" list-folded="true" list-max-height="250" storage-name="vuepress-plugin-meting" id="aplayer-fixed"></APlayer><canvas id="vuepress-canvas-cursor"></canvas><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.12534202.js" defer></script><script src="/assets/js/3.3275429a.js" defer></script><script src="/assets/js/1.97ecb029.js" defer></script><script src="/assets/js/29.f9b50025.js" defer></script>
  </body>
</html>
